<?xml version="1.0" encoding="UTF-8"?><treepad><file version="2" modified="2016/06/16 22:56:27"/><node name="人間にやさしいスクリプトをアセンブリ言語に変換するやつ(仮)" expanded="yes" selstart="285" sellength="0"><text>
「人間にやさしいスクリプトをアセンブリ言語に変換するやつ(仮)」とは

人間にやさしいスクリプトをアセンブリ言語に変換するやつである。
俗にコンパイラと呼ばれるものに似ているかもしれない。

大きく分けて、スクリプトを読み込むパートとアセンブリ元を書き出すパートに分かれる。

-----------

このドキュメントを書いているソフト：「ツリー帳」
http://www.vector.co.jp/soft/winnt/writing/se396498.html
http://kazina.com/treepad/index.html
</text><node name="スクリプトを読み込む" expanded="yes" selstart="18" sellength="0"><text>
まずはスクリプトを読み込む。
</text><node name="文法" expanded="yes" selstart="13" sellength="0"><text>
文法は大事である。
</text><node name="ファイルの取り込み" expanded="no" selstart="166" sellength="0"><text>
ファイルの取り込み
C言語でいうところの#include的なやつ

現在のファイルを基準にしたパスのファイルを取り込む
  include パス

ライブラリ用ディレクトリとして指定した場所を
基準にしたパスのファイルを取り込む
  uselib パス

無限再帰にならないように、適当な深さで打ち切る。
</text></node><node name="定数の定義" expanded="no" selstart="70" sellength="0"><text>
定数の定義

定数を定義する
  define 識別子 = 定数式

定数式とは、変数や関数の呼び出しを含まない式である。
</text></node><node name="変数の定義" expanded="no" selstart="88" sellength="0"><text>変数の定義

グローバル変数を定義する
(関数の定義中以外で)
  var 識別子 型

ローカル変数を定義する
(関数の定義中で)
  var 識別子 型
</text></node><node name="変数の宣言" expanded="no" selstart="97" sellength="0"><text>
変数の宣言

変数を宣言だけして定義しない
  vardeclare 識別子 型

アドレスを指定して変数を宣言する
  address 識別子 型 = アドレスを表す定数式
</text></node><node name="関数の定義" expanded="no" selstart="230" sellength="0"><text>
関数の定義
このスクリプトでの「関数」は、
C言語的な意味での関数、すなわちサブルーチンのようなものである。

関数の定義
  function 識別子 型(戻り値)
    引数の宣言(0個以上)
    関数の中身
  endfunction

引数の宣言
  param 識別子 型

引数の宣言(シンタックスシュガー)
  argument 識別子 型

引数は、関数の中で最初に書かれたものほど前の引数となる。
</text></node><node name="関数の宣言" expanded="no" selstart="61" sellength="0"><text>
関数の宣言

循環呼び出しがある場合などに用いる。

関数の宣言
  funcdeclare 識別子 型
</text></node><node name="条件分岐・ループ" expanded="yes" selstart="107" sellength="0"><text>
条件分岐・ループ

条件分岐
(関数宣言の中で)
  if 式1
    式1が0だったときにする処理
  elseif 式2
    式1が0で、式2が0以外だったときにする処理
  else
    式1も式2も0だったときにする処理
  endif

whileループ
(関数宣言の中で)
  while 式
    式が0以外だったときにする処理
  endwhile

無限ループ
(関数宣言の中で)
  loop
    繰り返す処理
  endloop
</text><node name="ループ脱出" expanded="no" selstart="161" sellength="0"><text>
ループ脱出

ループを抜け、次の処理に行く
  break

内側からn番目(1-origin)のループを抜け、次の処理に行く
  break n

ループの最初の処理に戻る
  continue

内側からn番目(1-origin)のループを抜け、次の処理に行く
  continue n
</text></node></node><node name="関数から戻る" expanded="no" selstart="66" sellength="0"><text>
関数から戻る

関数から戻る
  return

戻り値を指定して関数から戻る
  return 戻り値を表す式
</text></node><node name="式" expanded="yes" selstart="20" sellength="0"><text>
式

式は計算の基本である。
</text><node name="リテラル" expanded="no" selstart="185" sellength="0"><text>
リテラル

数値リテラル
  数値リテラルは、数値である。
  10進: 123
   8進: 0123
   2進: 0b1101
  16進: 0x123
  文字列の最初のバイト : '文字列' (文字列が0文字の場合文法エラー)

文字列リテラル
  文字列リテラルは、1バイトの符号なし整数の配列とみなせる。
  ""で囲まれる
</text></node><node name="識別子" expanded="no" selstart="67" sellength="0"><text>
識別子

識別子を用いて、変数や関数にアクセスできる。

識別子に利用可能な文字
  半角英アルファベット大文字、小文字
  数字 (識別子の1文字目には不可)
  アンダーバー
  全て0x80以上のバイトで表現される文字

識別子の処理 : 親に指示される
  ・値を取得する
    計算に使用する値を取得する。
  ・アドレスを取得する
    代入などに使用するアドレスを取得する。
</text></node><node name="演算子" expanded="yes" selstart="20" sellength="0"><text>
演算子は、計算を行うのに用いる。
</text><node name="単項演算子" expanded="no" selstart="131" sellength="0"><text>
単項演算子

-x : xに(-1)を掛ける
+x : x
!x : xが0以外なら0、xが0なら1
~x : xのビット反転
*x : ポインタxが指すデータ
&amp;x : xのアドレス
#x : xのバイト数(C言語のsizeof演算子)
</text></node><node name="二項演算子" expanded="no" selstart="7" sellength="0"><text>
二項演算子

計算
  x+y : 足し算
  x-y : 引き算
  x*y : 掛け算
  x/y : 割り算の商
  x%y : 割り算の余り
  x@y : 配列xのy番目の要素
  x&amp;y : ビット論理積
  x|y : ビット論理和
  x^y : ビット排他的論理和
  x&lt;&lt;y : ビット左シフト
  x&gt;&gt;y : ビット算術右シフト
  x&gt;&gt;&gt;y : ビット論理右シフト
  x^&lt;y : ビット左ローテート
  x&gt;^y : ビット右ローテート

比較 : 条件を満たせば1、満たさなければ0
  x&gt;y : xがyより大きい
  x&gt;=y : xがy以上
  x&lt;y : xがyより小さい
  x&lt;=y : xがy以下
  x==y : xがyと等しい
  x!=y : xがyと等しくない

代入
  x=y : xにyを代入
  (C言語でいうインクリメント、デクリメント、
   複合代入演算子を用意するかはTBD)

論理(短絡評価あり)
  x&amp;&amp;y : 「xが0でなく、かつyが0でない」なら1、そうでないなら0
  x||y : 「xが0でないか、yが0でない」なら1、そうでないなら0

関数呼び出し
  x() : 関数xを引数なしで呼び出す
  x(y) : 関数xを1個の引数yで呼び出す
  x(y,z) : 関数xを2個の引数y,zで呼び出す
  以下同様
</text></node><node name="演算子の優先順位と結合" expanded="no" selstart="57" sellength="0"><text>
演算子の優先順位と結合

↑高い
左結合: ()
右結合: 単項- 単項+ ! ~ 単項* 単項&amp; #
左結合: @
左結合: 二項* 二項/ %
左結合: 二項+ 二項-
左結合: &lt;&lt; &gt;&gt; &gt;&gt;&gt; ^&lt; &gt;^
左結合: 二項&amp;
左結合: | ^
右結合: =
左結合: &gt; &gt;= &lt; &lt;= == !=
左結合: &amp;&amp;
左結合: ||
↓低い
</text></node></node><node name="式をASTに変換する" expanded="no" selstart="801" sellength="0"><text>
式をASTに変換する

例: 234+b+-h(1+(3+hgg),nrr)&gt;&gt;&gt;4&gt;&gt;b^y^&lt;nrtrtr

まず1文字読み込み、トークンの種類を判別する
  空白 : スキップ
  数字または' : 数値リテラル
  " : 文字列リテラル
  識別子に利用可能な数字以外の文字 : 識別子
  その他 : 演算子(カッコや関数の引数を区切るコンマを含む)または文法エラー

数値リテラルや識別子 : 有効な最大長まで読む
文字列リテラル : 終わるまで読む
演算子 : 考えられる最大の長さのものを採用する

トークンに分割したら、前から順に処理する
例: 234 + b + - h ( 1 + ( 3 + hgg ) , nrr ) &gt;&gt;&gt; 4 &gt;&gt; b ^ y ^&lt; nrtrtr

次は演算子がくるはずフラグ(以下演算子フラグ) : 初期値false
関数の引数から何階層カッコが来ているか(以下関数階層) : 初期値1

スタック
  構築スタック、演算子スタック、階層スタックの3本
  初期値はいずれも空

演算子フラグがfalseのとき
  データ : 構築スタックにpushし、演算子フラグをtrueにする
  演算子 : 単項演算子やカッコとして演算子の処理を行う

演算子フラグがtrueのとき
  データ : 文法エラー
  演算子 : 二項演算子や関数呼び出しとして演算子の処理を行う

演算子の処理
  演算子スタックが空でなく、演算子スタック上の演算子の優先順位が
  処理している演算子より高いか、優先順位が同じで左結合である場合
    演算子スタックから演算子をpopし、適用する
  処理する演算子を演算子スタックにpushする

カッコの扱い
  開きカッコ(優先順位)
    今の関数階層を階層スタックにpushし、関数階層 = 関数階層 + 1
    演算子としては優先順位最低、右結合として扱う
  開きカッコ(関数呼び出し)
    今の関数階層を階層スタックにpushし、関数階層 = 0
    演算子としては優先順位最低、右結合として扱う
  閉じカッコ
    関数階層を階層スタックからpopする
    空きカッコが来るまで演算子スタックからpopして処理する
    空きカッコを演算子スタックからpopする
    popした空きカッコが関数呼び出しなら、関数呼び出しを演算子スタックにpushする

関数の引数の区切り,
  関数階層が0以外の時に出てきたら文法エラー
  演算子としては優先順位は空きカッコの次に低く、左結合として扱う
</text></node></node><node name="型" expanded="yes" selstart="34" sellength="0"><text>
型

型は変数をどう扱うかを決めるのに重要な役割を担う。
</text><node name="基本型" expanded="no" selstart="361" sellength="0" selected="yes"><text>
基本型

int8 : 1バイト符号つき整数
uint8 : 1バイト符号なし整数
byte : 1バイト符号なし整数 (uint8と同じ)
char : 1バイト符号なし整数 (uint8と同じ)

int16 : 2バイト符号つき整数
uint16 : 2バイト符号なし整数

int32 : 4バイト符号付き整数
uint32 : 4バイト符号なし整数
int: 4バイト符号付き整数 (int32と同じ)
uint : 4バイト符号なし整数 (uint32と同じ)

func : 関数

「関数」のデータの実体は、典型的には関数の先頭アドレスである。
C言語と異なり、関数が勝手にポインタとして扱われることはない。

(TODO: 「関数」に戻り値の型の情報を入れる)
</text></node><node name="派生型" expanded="no" selstart="301" sellength="0"><text>
派生型

(型)* : (型)を指すポインタ
(型)[要素数を表す定数式] : (型)を要素とする配列

例
  int : 4バイト符号付き整数(以下、整数)
  int* : 整数を指すポインタ
  int[5] : 整数の配列
  int*[5] : 整数を指すポインタの配列
  int[5]* : 整数の配列を指すポインタ
  int[5][10] : 整数の配列の配列
    (要素にアクセスするときは、hoge@(0～9)@(0～4)のようになる)
  func : 関数
  func* : 関数を指すポインタ
  func[5] : 関数の配列
</text></node></node><node name="コメント" expanded="no" selstart="15" sellength="0"><text>
コメント

TBD
</text></node></node><node name="データ構造" expanded="no" selstart="41" sellength="0"><text>
データ構造

読み込んだスクリプトを表現するデータ構造。

TBD
</text></node></node><node name="アセンブリ言語を書き出す" expanded="yes" selstart="73" sellength="0"><text>
スクリプトを読み込んだら、それに基づいてアセンブリ言語を書き出す。
オブジェクト指向の考え方を用いて、複数のアーキテクチャに対応したい。
</text><node name="式の処理" expanded="yes" selstart="120" sellength="0"><text>
レジスタを使った式の評価の方法を考える。
記号を以下のようにおく。

レジスタ上限 = n
結果を格納するレジスタ r1
ワーキングレジスタ r2, ... , rn

式を計算(r1, [r2, ... , rn])
</text><node name="二項演算子" expanded="no" selstart="551" sellength="0"><text>
左辺使用レジスタ数x : [1, n]
右辺使用レジスタ数y : [1, n]
とおく。

y &lt; x &lt;= n のとき

  擬似コード:
    左辺を計算(r1, [r2, ... , rn])
    右辺を計算(r2, [r3, ... , rn])
    op r1, r2

  使用レジスタ数 = x

x &lt; y &lt;= n のとき

  擬似コード:
    右辺を計算(r2, [r1, r3, ... , rn])
    左辺を計算(r1, [r3, ... , rn])
    op r1, r2

  使用レジスタ数 = y

x = y &lt; n のとき

  擬似コード:
    左辺を計算(r1, [r2, ... , rn])
    右辺を計算(r2, [r3, ... , rn])
    op r1, r2

  使用レジスタ数 = x + 1

x = y = n のとき

  擬似コード:
    右辺を計算(r1, [r2, ... , rn])
    push r1
    左辺を計算(r2, [r1, r3, ... , rn])
    pop r1
    op r1, r2

  使用レジスタ数 = x
</text></node><node name="単項演算子" expanded="no" selstart="77" sellength="0"><text>
オペランド使用レジスタ数 x : [1, n]
とする。

擬似コード:
  オペランドを計算(r1, [r2, ... , rn])
  op r1

使用レジスタ数 = x
</text></node><node name="関数呼び出し" expanded="no" selstart="106" sellength="0"><text>
呼び出し対象の使用レジスタ数x : [1, n]
k番目(k=1, ... , m)の引数使用レジスタ数y_k : [1, n]
とする。

擬似コード:
  関数呼び出しで破壊される、
    ワーキングレジスタおよび結果を格納するレジスタ以外のレジスタを退避
  m番目の引数を計算(r1, [r2, ... , rn])
  push r1
  m-1番目の引数を計算(r1, [r2, ... , rn])
  push r1
  ...
  1番目の引数を計算(r1, [r2, ... , rn])
  push r1
  呼び出し対象を計算(r1, [r2, ... , rn])
  call *r1
  スタックに詰んだ引数を消す
  mov r1, 関数の返り値
  退避したレジスタを復帰

使用レジスタ数 = max(x, y_1, y_2, ... , y_m)
</text></node></node></node></node></treepad>