技術メモ
--------

概要
====

「人間にやさしいスクリプトをアセンブリ言語に変換するやつ(仮)」とは

人間にやさしいスクリプトをアセンブリ言語に変換するやつである。
俗にコンパイラと呼ばれるものに似ているかもしれない。

大きく分けて、スクリプトを読み込むパートとアセンブリ言語を書き出すパートに分かれる。

スクリプトを読み込む
====================

### ファイルの取り込み

無限再帰にならないように、適当な深さで打ち切る。

### 識別子

識別子の処理は親に指示される。

* 値を取得する
  * 計算に使用する値を取得する。
* アドレスを取得する
  * 代入などに使用するアドレスを取得する。

### 式をASTに変換する

```
例: 234+b+-h(1+(3+hgg),nrr)>>>4>>b^y^<nrtrtr

まず1文字読み込み、トークンの種類を判別する
  空白 : スキップ
  数字または' : 数値リテラル
  " : 文字列リテラル
  識別子に利用可能な数字以外の文字 : 識別子
  その他 : 演算子(カッコや関数の引数を区切るコンマを含む)または文法エラー

数値リテラルや識別子 : 有効な最大長まで読む
文字列リテラル : 終わるまで読む
演算子 : 考えられる最大の長さのものを採用する

トークンに分割したら、前から順に処理する
例: 234 + b + - h ( 1 + ( 3 + hgg ) , nrr ) >>> 4 >> b ^ y ^< nrtrtr

次は演算子がくるはずフラグ(以下演算子フラグ) : 初期値false
関数の引数から何階層カッコが来ているか(以下関数階層) : 初期値1

スタック
  構築スタック、演算子スタック、階層スタックの3本
  初期値はいずれも空

演算子フラグがfalseのとき
  データ : 構築スタックにpushし、演算子フラグをtrueにする
  演算子 : 単項演算子やカッコとして演算子の処理を行う

演算子フラグがtrueのとき
  データ : 文法エラー
  演算子 : 二項演算子や関数呼び出しとして演算子の処理を行う

演算子の処理
  演算子スタックが空でなく、演算子スタック上の演算子の優先順位が
  処理している演算子より高いか、優先順位が同じで左結合である場合
    演算子スタックから演算子をpopし、適用する
  処理する演算子を演算子スタックにpushする

カッコの扱い
  開きカッコ(優先順位)
    今の関数階層を階層スタックにpushし、関数階層 = 関数階層 + 1
    演算子としては優先順位最低、右結合として扱う
  開きカッコ(関数呼び出し)
    今の関数階層を階層スタックにpushし、関数階層 = 0
    演算子としては優先順位最低、右結合として扱う
  閉じカッコ
    関数階層を階層スタックからpopする
    空きカッコが来るまで演算子スタックからpopして処理する
    空きカッコを演算子スタックからpopする
    popした空きカッコが関数呼び出しなら、関数呼び出しを演算子スタックにpushする

関数の引数の区切り,
  関数階層が0以外の時に出てきたら文法エラー
  演算子としては優先順位は空きカッコの次に低く、左結合として扱う
```

アセンブリ言語を書き出す
========================

スクリプトを読み込んだら、それに基づいてアセンブリ言語を書き出す。
オブジェクト指向の考え方を用いて、複数のアーキテクチャに対応したい。

### 式の処理

レジスタを使った式の評価の方法を考える。
記号を以下のようにおく。

レジスタ上限 `n`
結果を格納するレジスタ `r1`
ワーキングレジスタ `r2, ... , rn`

`式を計算(r1, [r2, ... , rn])`

#### 二項演算子

```
左辺使用レジスタ数x : [1, n]
右辺使用レジスタ数y : [1, n]
とおく。

y < x <= n のとき

  擬似コード:
    左辺を計算(r1, [r2, ... , rn])
    右辺を計算(r2, [r3, ... , rn])
    op r1, r2

  使用レジスタ数 = x

x < y <= n のとき

  擬似コード:
    右辺を計算(r2, [r1, r3, ... , rn])
    左辺を計算(r1, [r3, ... , rn])
    op r1, r2

  使用レジスタ数 = y

x = y < n のとき

  擬似コード:
    左辺を計算(r1, [r2, ... , rn])
    右辺を計算(r2, [r3, ... , rn])
    op r1, r2

  使用レジスタ数 = x + 1

x = y = n のとき

  擬似コード:
    右辺を計算(r1, [r2, ... , rn])
    push r1
    左辺を計算(r2, [r1, r3, ... , rn])
    pop r1
    op r1, r2

  使用レジスタ数 = x
```

#### 単項演算子

```
オペランド使用レジスタ数 x : [1, n]
とする。

擬似コード:
  オペランドを計算(r1, [r2, ... , rn])
  op r1

使用レジスタ数 = x
```

#### 関数呼び出し

```

呼び出し対象の使用レジスタ数x : [1, n]
k番目(k=1, ... , m)の引数使用レジスタ数y_k : [1, n]
とする。

擬似コード:
  関数呼び出しで破壊される、
    ワーキングレジスタおよび結果を格納するレジスタ以外のレジスタを退避
  m番目の引数を計算(r1, [r2, ... , rn])
  push r1
  m-1番目の引数を計算(r1, [r2, ... , rn])
  push r1
  ...
  1番目の引数を計算(r1, [r2, ... , rn])
  push r1
  呼び出し対象を計算(r1, [r2, ... , rn])
  call *r1
  スタックに詰んだ引数を消す
  mov r1, 関数の返り値
  退避したレジスタを復帰

使用レジスタ数 = max(x, y_1, y_2, ... , y_m)
```
